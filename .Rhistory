bf.df %>% filter(Gender == "M") -> bf.df2
ggpairs(bf.df2[,c(4,5,8,9,10)], cardinality_threshold = 21, aes(color = Age, alpha = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase)) + geom_bar(show.legend = T, stat = "identity") +     xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto de los hombres") + facet_wrap(~ Gender)
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase)) + geom_bar(show.legend = T, stat = "identity") +     xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender)
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = City_Category)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Marital_Status)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_boxplot() + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto")
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Purchase)) + geom_boxplot() + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto")
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot() + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto")
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot(show.legend = F) + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto") + theme(plot.title = element_text(hjust = 0.5))
shiny::runApp()
runApp()
?tags
runApp()
runApp()
runApp()
runApp()
runApp()
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
runApp()
runApp()
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ NA) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ ) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ 0) + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ " ") + theme(plot.title = element_text(hjust = 0.5))
runApp()
runApp()
runApp()
bf.df[[NA]]
runApp()
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
library(igraph)
?as.igraph
make_bipartite_graph(bf.df[1,2])
make_bipartite_graph(bf.df[1], bf.df[2])
graph_from_data_frame(d=bf.df[,c(1,2)], directed = F)
graph_from_data_frame(d=bf.df[,c(1,2)], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[,c(1,2)], directed = F) %>% plot(layout = layout_as_bipartite, vertex.color=c("green","cyan")[V()$type+1])
graph_from_data_frame(d=bf.df[,c(1,2)], directed = F) %>% plot(layout = layout_as_bipartite)
bf.df[,c(1,2)]
?graph_from
?graph_from_data_frame
graph_from_data_frame(d=bf.df[10,c(1,2)], directed = F) %>% plot(layout = layout_as_bipartite)
graph_from_data_frame(d=bf.df[10,c(1,2)], directed = F)
graph_from_data_frame(d=bf.df[10,c(1,2)], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[c(:10),c(1,2)], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% plot(layout = layout_as_bipartite)
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% as.bipartite() %>% plot()
?as_bipartite
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% layout_as_bipartite() %>% plot()
make_bipartite_graph(bf.df[,1],bf.df[,2], directed = F) %>% plot()
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>% layout_as_bipartite(types = ) %>% plot()
graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>%  plot()
g = graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>%  plot()
V(g)$type <- FALSE
g = graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F) %>%  plot()
V(g)$type <- FALSE
V(g)$type <- FALSE
g = graph_from_data_frame(d=bf.df[c(1:10),c(1,2)], directed = F)
V(g)$type <- FALSE
V(g)$type[V(g)$name == c(1:5)] <- TRUE
plot(g)
plot(g, layout_as_bipartite)
layout_as_bipartite(g)
plot(layout_as_bipartite(g))
layout_as_bipartite(g)
V(g)$name == c(1:5)
V(g)$type[V(g)$name == c(1)] <- TRUE
V(g)$name == c(1)
V(g)$name
bf.df[c(1:10),c(1,2)]
plot(layout_as_bipartite(g))
plot(g, layout = bipartite)
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
#En mi pc tarda un poco en cargar los gráficos. Espero que con un procesador más potente sea más fluido.
knitr::include_app("http://127.0.0.1:3977", height = 750)
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot(show.legend = F) + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto") + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
ggpairs(bf.df[,c(6,7,8,10)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
bf.rec = data.matrix(bf.df)
bf.rec = as(bf.rec, "realRatingMatrix")
ubcf = Recommender(data = bf.rec, method = "UBCF")
knitr::opts_chunk$set(echo = TRUE)
entrenamiento = createDataPartition(bf.rec$User_ID, p=0.6, list=FALSE)
library(caret)
entrenamiento = createDataPartition(bf.rec$User_ID, p=0.6, list=FALSE)
entrenamiento = createDataPartition(bf.rec, p=0.6, list=FALSE)
entrenamiento = createDataPartition(bf.df$User_ID, p=0.6, list=FALSE)
train = bf.rec[entrenamiento,]
View(bf.rec)
train = bf.rec[1:430061]
test = bf.rec[430062:537577]
recom_hibrida = HybridRecommender(
Recommender(train, method = "UBCF"),
Recommender(train, method = "RANDOM"),
weights = c(0.85, 0.15))
as(predict(recom_hibrida, test, 5), "list")
test = bf.rec[430062:430072]
recom_hibrida = HybridRecommender(
Recommender(train, method = "UBCF"),
Recommender(train, method = "RANDOM"),
weights = c(0.85, 0.15))
as(predict(recom_hibrida, test, 5), "list")
recom_hibrida = HybridRecommender(
Recommender(train, method = "UBCF"),
Recommender(train, method = "RANDOM"),
weights = c(0.8, 0.2))
as(predict(recom_hibrida, test, 5), "list")
data("MovieLense")
View(MovieLense)
bf.df$Product_ID = as.character(bf.df$Product_ID)
bf.rec = data.matrix(bf.df)
View(bf.rec)
View(bf.df)
bf.rec = as(bf.df, "realRatingMatrix")
bf.rec = as(bf.df, "realRatingMatrix")
bf.rec = data.matrix(bf.df)
View(bf.df)
View(bf.rec)
bf.rec[2,]
bf.rec[,2]
bf.rec[,2] = bf.df$Product_ID
View(bf.rec)
View(bf.df)
View(bf.df)
bf.rec = as(bf.df, "realRatingMatrix")
bf.rec = as(bf.rec, "realRatingMatrix")
View(bf.rec)
bf.rec[,2]
bf.rec[[,2]]
bf.rec[1,2]
bf.rec[,2] = bf.df$Product_ID
bf.rec = as(bf.df[,1:3], "realRatingMatrix")
bf.rec = as(bf.df[,1:2], "realRatingMatrix")
bf.rec = as(bf.df[,3:5], "realRatingMatrix")
bf.rec = as(bf.df[,8:10], "realRatingMatrix")
rec = Recommender(train, method = "UBCF")
as(predict(rec, test, 5), "list")
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot(show.legend = F) + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto") + theme(plot.title = element_text(hjust = 0.5))
ggpairs(bf.df[,c(6,7,8,10)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
group_by(User_ID)
bf.df = bf.df %>% group_by(User_ID)
View(bf.df)
bf.df = bf.df %>% group_by(User_ID)
?summarise
Gender[1]
bf.df$Gender[1]
bf.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1],
City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1],
Marital_Status = Marital_Status[1], Purchase = sum(Purchase), Item_Count = n())
View(bf.df)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1],
City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1],
Marital_Status = Marital_Status[1], Purchase = sum(Purchase), Item_Count = n())
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bf.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1],
City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1],
Marital_Status = Marital_Status[1], Purchase = sum(Purchase), Item_Count = n())
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
bf.df$
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
ggpairs(bf.df[,c(6,7,8,10)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
ggpairs(bf.df[,c(6,7,8)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
bfcant.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1],
City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1],
Marital_Status = Marital_Status[1], Item_Count = n())
ggpairs(bfcant.df)
ggpairs(bfcant.df[,c(2:9)])
ggpairs(bfcant.df[,c(2:8)])
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bfcant.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1],
City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1],
Marital_Status = Marital_Status[1], Item_Count = n())
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
ggpairs(bf.df[,c(6,7,8,10)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
ggpairs(bfcant.df[,c(2:8)], cardinality_threshold = 21)
ggpairs(bfcant.df[,c(3:8)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
ggpairs(bfcant.df[,c(3:8)], cardinality_threshold = 21, aes(color = bf.df$Gender, alpha = 0.5))
ggpairs(bfcant.df[,c(3:8)], cardinality_threshold = 21, aes(color = bfcant.df$Gender, alpha = 0.5))
View(bf.df)
ggpairs(bfcant.df[,c(5:8)], cardinality_threshold = 21, aes(color = bfcant.df$Gender, alpha = 0.5))
bf.df$City_Category %>% count(Purchase)
bf.df$City_Category["A"] %>% count(Purchase)
bf.df$City_Category[A] %>% count(Purchase)
bf.df$City_Category %>% sum(Purchase)
bf.df$City_Category
bf.df %>% plot(x = City_Category, y = Purchase)
bf.df %>% plot(aes(x = City_Category, y = Purchase)
bf.df %>% plot(aes(x = City_Category, y = Purchase))
bf.df %>% plot(x = bf.df$City_Category, y = bf.df$Purchase)
bf.df %>% plot(x = bf.df$City_Category, y = bf.df$Purchase)
bfcant.df %>% plot(x = bfcant.df$City_Category, y = bfcant.df$Item_Count)
bf.df %>% ggplot(x = bf.df$City_Category, y = bf.df$Purchase) + geom_bar()
bf.df %>% ggplot(aes(x = City_Category, y = Purchase)) + geom_bar()
ggplot(bf.df, aes(x = City_Category, y = Purchase)) + geom_bar()
ggplot(bf.df, aes(x = City_Category, y = Purchase)) + geom_bar(show.legend = F, stat = "identity")
ggplot(bf.df, aes(x = City_Category, y = Purchase)) + geom_bar(show.legend = F, stat = "identity")
ggplot(bfcant.df, aes(x = City_Category, y = Item_Count)) + geom_bar(show.legend = F, stat = "identity")
ggpairs(bfcant.df[,c(5:8)], cardinality_threshold = 21, aes(color = bfcant.df$Gender, alpha = 0.5))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
library(caret)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
library(caret)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
library(caret)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
#En mi pc tarda un poco en cargar los gráficos. Espero que con un procesador más potente sea más fluido.
#knitr::include_app("http://127.0.0.1:3977", height = 750)
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot(show.legend = F) + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto") + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bfcant.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1], City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1], Marital_Status = Marital_Status[1], Item_Count = n())
#Se juntan los compradores para no desvirtuar los resultados de las próximas graficas al cruzar variables factor entre ellas ya que de no ser así se contabilizarían de forma multiple los usuarios con más de una compra.
ggpairs(bfcant.df[,c(5:8)], cardinality_threshold = 21, aes(color = bfcant.df$Gender, alpha = 0.5))
bfcant.df = bf.df %>%
gather(observation, Val, Product_ID) %>%
group_by(User_ID,observation, Val) %>%
summarise(n= n()) %>%
ungroup() %>%
spread(Val, n, fill=0)
bfcant.df = bfcant.df[,-c(1,2)]
bf.bin = data.matrix(bfcant.df)
bf.bin = as(bf.bin, "binaryRatingMatrix")
sep = sample(x= c(T, F),
size = nrow(bf.bin),
replace = T,
prob = c(0.8, 0.2))
train = bf.bin[sep,]
test = bf.bin[!sep,]
recom_hibrida = HybridRecommender(
Recommender(train, method = "IBCF", parameter = list(method = "Jaccard")),
Recommender(train, method = "RANDOM"),
weights = c(0.8, 0.2))
getModel(recom_hibrida)
pred = predict(object = recom_hibrida, newdata = test, n = 10)
rec.matrix = sapply(pred@items, function(x){
colnames(bf.bin[,x])
})
View(rec.matrix[,1:5])
knitr::opts_chunk$set(echo = TRUE)
getModel(recom_hibrida)
getModel(recom_hibrida[[1]])
getModel(recom_hibrida[1])
getModel(recom_hibrida(1))
#Se entrena el modelo con el subconjunto de entrenamiento.
recom_hibrida = HybridRecommender(
Recommender(train, method = "UBCF", parameter = list(method = "Jaccard")),
Recommender(train, method = "RANDOM"),
weights = c(0.8, 0.2))
pred = predict(object = recom_hibrida, newdata = test, n = 10)
rec.matrix2 = sapply(pred@items, function(x){
colnames(bf.bin[,x])
})
View(rec.matrix2[,1:5])
View(rec.matrix2[,1:5])
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
knitr::opts_chunk$set(echo = TRUE)
plot(res, "prec/rec", annotate = T, main = "preciosión vs Eficacia")
res = evaluate(x = eval_sets,
method = "UBCF", parameter = list(method = "Jaccard"),
n = seq(10,100,10))
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
library(caret)
res = evaluate(x = eval_sets,
method = "UBCF", parameter = list(method = "Jaccard"),
n = seq(10,100,10))
#Se usa validación cruzada para validar las recomendaciones.
eval_sets = evaluationScheme(data = bf.bin,
method = "cross-validation",
k = 5,
given = 15)
set.seed(2019)
bf.bin = bf.bin[rowCounts(bf.bin) > 40,
colCounts(bf.bin) > 80]
#Se usa validación cruzada para validar las recomendaciones.
eval_sets = evaluationScheme(data = bf.bin,
method = "cross-validation",
k = 5,
given = 15)
modelos = list(IBCF_cos = list(name = "IBCF", params = list(method = "cosine")),
IBCF_cor = list(name = "IBCF", params = list(method = "pearson")),
IBCF_jac = list(name = "IBCF", params = list(method = "Jaccard")),
UBCF_cos = list(name = "UBCF", params = list(method = "cosine")),
UBCF_cor = list(name = "UBCF", params = list(method = "pearson")),
UBCF_jac = list(name = "UBCF", params = list(method = "Jaccard")),
random = list(name = "RANDOM", params = NULL))
resul = evaluate(x = eval_sets,
method = modelos,
n = c(1:7, seq(10,100,10)))
plot(resul, annotate = 1, legend = "topleft") + title("Curva AUC")
plot(resul, "prec/rec", annotate = 1, legend = "bottomright") + title("Precisión vs Eficacia")
res = evaluate(x = eval_sets,
method = "UBCF", parameter = list(method = "Jaccard"),
n = seq(10,100,10))
getConfusionMatrix(res)[[1]]
plot(res, "prec/rec", annotate = T, main = "preciosión vs Eficacia")
?Recommender
knitr::opts_chunk$set(echo = TRUE)
#Se muestran 12 recomendaciones para los 5 primeros usuarios, de esta manera comprobamos que funcione correctamente.
rec.matrix[,1:5]
#Se procede a la predicción con el subconjunto de test.
pred = predict(object = recom_hibrida, newdata = test, n = 12)
set.seed(2019)
#Seleccion de usuarios con al menos 40 compras y productos comprados como mínimo 80 veces.
bf.bin = bf.bin[rowCounts(bf.bin) > 40,
colCounts(bf.bin) > 80]
library(tidyverse)
library(webshot)
library(GGally)
library(recommenderlab)
library(caret)
bf.df = read_csv("BlackFriday.csv") #Se cargan directamente los datos en una tibble
bf.df %>% summary() #Se comprueban los datos que contiene para saber como tratarlos
bf.df %>% str()
bf.df %>% head()
bf.df %>% tail()
bf.df = mutate(bf.df[,-c(10:11)]) %>% na.omit %>% droplevels() #Se eliminan NAs (Especialmente concentrados en las columnas Product_Category 2 y 3)
bf.df = bf.df[!duplicated(bf.df),] #Se eliminan duplicados en caso de haberlos
bf.df$User_ID = bf.df$User_ID - 1000000 #Se convierten User_ID en números del 1 al 6040
bf.df$User_ID = as.factor(bf.df$User_ID) #Se transforman a factor los datos que se considera oportuno
bf.df$Product_ID = as.factor(bf.df$Product_ID)
bf.df$Gender = as.factor(bf.df$Gender)
bf.df$Age = as.factor(bf.df$Age)
bf.df$City_Category = as.factor(bf.df$City_Category)
bf.df$Marital_Status = as.factor(bf.df$Marital_Status)
bf.df$Stay_In_Current_City_Years = as.factor(bf.df$Stay_In_Current_City_Years)
bf.df$Product_Category_1 = as.factor(bf.df$Product_Category_1)
bf.df$Occupation = as.factor(bf.df$Occupation)
bf.df %>% summary() #De nuevo se comprueban los datos para confirmar que ya estén "limpios"
bf.df %>% str()
#En mi pc tarda un poco en cargar los gráficos. Espero que con un procesador más potente sea más fluido.
#knitr::include_app("http://127.0.0.1:4231", height = 750)
bf.df %>%  ggplot(aes(x = Product_Category_1, y = Purchase, color = Product_Category_1)) + geom_boxplot(show.legend = F) + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto") + theme(plot.title = element_text(hjust = 0.5))
bf.df %>% ggplot(aes(x = Product_Category_1, y = Purchase, color = Age)) + geom_bar(show.legend = T, stat = "identity") + xlab("Categoría de producto") + ylab("Gasto") + ggtitle("Gasto por categoría de producto mujeres frente a hombres") + facet_wrap(~ Gender) + theme(plot.title = element_text(hjust = 0.5))
bfcant.df = bf.df %>% group_by(User_ID) %>% summarise(Gender = Gender[1],Age = Age[1],Occupation = Occupation[1], City_Category = City_Category[1], Stay_In_Current_City_Years = Stay_In_Current_City_Years[1], Marital_Status = Marital_Status[1], Item_Count = n())
#Se juntan los compradores para no desvirtuar los resultados de las próximas graficas al cruzar variables factor entre ellas ya que de no ser así se contabilizarían de forma multiple los usuarios con más de una compra.
ggpairs(bfcant.df[,c(5:8)], cardinality_threshold = 21, aes(color = bfcant.df$Gender, alpha = 0.5))
#Se transforma el data frame pasando cada factor de la columna Product_ID a una variable propia con el ID del producto y de esta manera transformar el data frame en una matriz binaria con 0 en caso de no haber comprado el producto y 1 en caso de si haberlo comprado.
bfcant.df = bf.df %>%
gather(observation, Val, Product_ID) %>%
group_by(User_ID,observation, Val) %>%
summarise(n= n()) %>%
ungroup() %>%
spread(Val, n, fill=0)
#Se eliminan las columnas 1 y 2 que corresponden a User_ID (ya recogido en el índice) y a una columna que recoge "Product_ID" ya que es el nombre de la columna original.
bfcant.df = bfcant.df[,-c(1,2)]
#Por ultimo se transforma el data frame en una binaryRatingMatrix para poder trabajar y entrenar el modelo.
bf.bin = data.matrix(bfcant.df)
bf.bin = as(bf.bin, "binaryRatingMatrix")
set.seed(2019)
#Seleccion de usuarios con al menos 40 compras y productos comprados como mínimo 80 veces.
bf.bin = bf.bin[rowCounts(bf.bin) > 40,
colCounts(bf.bin) > 80]
#Se usa validación cruzada para validar las recomendaciones.
eval_sets = evaluationScheme(data = bf.bin,
method = "cross-validation",
k = 5,
given = 20)
#Los modelos a comparar son basados en usuarios, basados en items (mediante distintos metodos), y por ultimo un modelo aleatorio.
modelos = list(IBCF.cos = list(name = "IBCF", params = list(method = "cosine")),
IBCF.cor = list(name = "IBCF", params = list(method = "pearson")),
IBCF.jac = list(name = "IBCF", params = list(method = "Jaccard")),
UBCF.cos = list(name = "UBCF", params = list(method = "cosine")),
UBCF.cor = list(name = "UBCF", params = list(method = "pearson")),
UBCF.jac = list(name = "UBCF", params = list(method = "Jaccard")),
random = list(name = "RANDOM", params = NULL))
resul = evaluate(x = eval_sets,
method = modelos,
n = c(1:7, seq(10,100,10)))
plot(resul, annotate = 1, legend = "topleft") + title("Curva AUC")
plot(resul, "prec/rec", annotate = 1, legend = "bottomright") + title("Precisión vs Eficacia")
res.jac = evaluate(x = eval_sets,
method = "UBCF", parameter = list(method = "Jaccard"),
n = seq(10,100,10))
getConfusionMatrix(res.jac)[[1]]
plot(res.jac, "prec/rec", annotate = T, main = "Precisión vs Eficacia (UBFC Jaccard)")
#Se separan los datos en dos grupos, uno de entrenamiento y otro de prueba.
sep = sample(x= c(T, F),
size = nrow(bf.bin),
replace = T,
prob = c(0.8, 0.2))
train = bf.bin[sep,]
test = bf.bin[!sep,]
#Se entrena el modelo con el subconjunto de entrenamiento.
recom_hibrida = HybridRecommender(
Recommender(train, method = "UBCF", parameter = list(method = "Jaccard")),
Recommender(train, method = "RANDOM"),
weights = c(0.85, 0.15))
#Se procede a la predicción con el subconjunto de prueba.
pred = predict(object = recom_hibrida, newdata = test, n = 12)
rec.matrix = sapply(pred@items, function(x){
colnames(bf.bin[,x])
})
#Se muestran 12 recomendaciones para los 5 primeros usuarios, de esta manera comprobamos que funcione correctamente.
rec.matrix[,1:5]
